[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "blog",
    "section": "",
    "text": "Probability theory and random variables\nClustering\nLinear and nonlinear regression\nClassification\nAnomaly/outlier detection"
  },
  {
    "objectID": "1-probability.html",
    "href": "1-probability.html",
    "title": "Probability theory and random variables",
    "section": "",
    "text": "Here’s the definition; taken from Wikipedia, which in order takes it from Fristedt and Gray (1996, 11).\n\nDefinition 1 (Random variable). Let \\((\\Omega, \\mathcal{F}, P)\\) be a probability space and \\((E, \\mathcal{E})\\) a measurable space. Then an \\((E, \\mathcal{E})\\)-valued random variable is a measurable function \\(X : \\Omega \\to E\\), which measures that, for every subset \\(B \\in \\mathcal{E}\\), its preimage is \\(\\mathcal{F}\\)-measurable; \\(X^{-1}(B) \\in \\mathcal{F}\\), where \\(X^{-1}(B) = \\{\\omega : X(\\omega) \\in B\\}\\)."
  },
  {
    "objectID": "1-probability.html#random-variables",
    "href": "1-probability.html#random-variables",
    "title": "Probability theory and random variables",
    "section": "",
    "text": "Here’s the definition; taken from Wikipedia, which in order takes it from Fristedt and Gray (1996, 11).\n\nDefinition 1 (Random variable). Let \\((\\Omega, \\mathcal{F}, P)\\) be a probability space and \\((E, \\mathcal{E})\\) a measurable space. Then an \\((E, \\mathcal{E})\\)-valued random variable is a measurable function \\(X : \\Omega \\to E\\), which measures that, for every subset \\(B \\in \\mathcal{E}\\), its preimage is \\(\\mathcal{F}\\)-measurable; \\(X^{-1}(B) \\in \\mathcal{F}\\), where \\(X^{-1}(B) = \\{\\omega : X(\\omega) \\in B\\}\\)."
  },
  {
    "objectID": "1-probability.html#concentration-bounds",
    "href": "1-probability.html#concentration-bounds",
    "title": "Probability theory and random variables",
    "section": "Concentration bounds",
    "text": "Concentration bounds\n\nHoeffding’s inequality\n\n\nExample"
  },
  {
    "objectID": "1-probability.html#multi-armed-bandits",
    "href": "1-probability.html#multi-armed-bandits",
    "title": "Probability theory and random variables",
    "section": "Multi-armed bandits",
    "text": "Multi-armed bandits\nBased on Slivkins (2022)\n\n\n\\begin{algorithm} \\caption{Stochastic MAB (Framework)} \\begin{algorithmic} \\Require{$K$ and $T$ (both known), unknown reward distributions $\\mathcal{D}_a$.} \\For{$t = 1, 2, \\ldots$} \\State Choose an action $a_t \\in [K]$. \\State Suffer loss $z_t[a_t]$ and also only observe $z_t[a_t]$. \\EndFor \\end{algorithmic} \\end{algorithm}\n\n\nHere, \\(z_t\\) is a random vector sampled from the unknown distributions, i.e., \\(z_t[a] \\sim \\mathcal{D}_a\\).\n\nExplore-then-exploit\nJi (2022, Lecture 14)\n\n\n\\begin{algorithm} \\caption{Explore-then-exploit} \\begin{algorithmic} \\Require{$K$ and $T$ (both known), unknown reward distributions $\\mathcal{D}_a$.} \\For{$t = 1, 2, \\ldots$} \\State Explore phase: try each arm $N$ times. \\State Exploit phase: determine $\\tilde{a}$ with the highest average reward; then play $\\tilde{a}$ in all remaining rounds. \\EndFor \\end{algorithmic} \\end{algorithm}\n\n\n\\(N = 2 \\sqrt[3]{T^2 \\log T / K^2}\\)\n\n\nCode for Explore-then-exploit\nfrom math import log\nfrom numpy import argmax\n\nclass ExploreExploit:\n    def __init__(self, K, T):\n        self.K = K\n        self.N = round(2 * (T**2 * log(T) / K**2)**(1/3))\n        self.totals = [0] * K\n    \n    def __str__(self):\n        return \"Explore-then-exploit\"\n\n    def play(self, t):\n        '''Choose an arm to play.'''\n        if t &lt;= self.K*self.N:\n            # Play each arm N times\n            return t % self.K\n        else:\n            # Play best arm\n            return self.best\n    \n    def feedback(self, t, a, r):\n        '''Receive a reward.'''\n        if t &lt;= self.K*self.N:\n            # Record reward\n            self.totals[a] += r\n        if t == self.K*self.N:\n            # Compute best arm\n            self.best = argmax(self.totals)\n\n\n\n\nEpsilon-greedy\nJi (2022, Lecture 14)\n\n\n\\begin{algorithm} \\caption{Epsilon-greedy} \\begin{algorithmic} \\Require{$K$ and $T$ (both known), unknown reward distributions $\\mathcal{D}_a$.} \\For{$t = 1, 2, \\ldots$} \\State Toss a coin with success rate $\\epsilon_t$. \\If{success} \\State Explore: choose an arm uniformly at random. \\Else \\State Exploit: choose an arm with the highest average reward so far. \\EndIf \\EndFor \\end{algorithmic} \\end{algorithm}\n\n\n\n\nCode for Epsilon-greedy\nfrom math import log\nfrom random import random, randrange\nfrom numpy import argmax, divide, errstate, inf, nan\n\nclass EpsilonGreedy:\n    def __init__(self, K, _):\n        self.K = K\n        self.totals = [0] * K\n        self.counts = [0] * K\n    \n    def __str__(self):\n        return \"Epsilon-greedy\"\n\n    def _eps(self, t):\n        return (self.K*log(t)/t)**(1/3)\n\n    def _best(self):\n        with errstate(divide='ignore', invalid='ignore'):\n            avg = divide(self.totals, self.counts)\n        avg[avg == inf] = -inf\n        avg[avg == nan] = -inf\n        return argmax(avg)\n\n    def play(self, t):\n        '''Choose an arm to play.'''\n        if random() &lt; self._eps(t):\n            # Play random arm\n            return randrange(self.K)\n        else:\n            # Play best arm\n            return self._best()\n    \n    def feedback(self, t, a, r):\n        '''Receive a reward.'''\n        self.totals[a] += r\n        self.counts[a] += 1\n\n\n\n\nSuccessive elimination\nJi (2022, Lecture 14)\n\n\n\\begin{algorithm} \\caption{Successive Elimination} \\begin{algorithmic} \\Require{$K$ and $T$ (both known), unknown reward distributions $\\mathcal{D}_a$.} \\State Initialize active arm set $\\mathcal{A}_1 = [K]$. \\For{$p = 1, 2, \\ldots$} \\State Play each arm in $\\mathcal{A}_p$ once. \\State Let $t$ be the time at the end of the current phase $p$. \\State $\\mathcal{A}_{p+1} = \\{ a \\in \\mathcal{A}_p : \\mathrm{UCB}_t (a) \\geq \\max_{a' \\in \\mathcal{A}_p} \\mathrm{LCB}_t (a) \\}$ \\EndFor \\end{algorithmic} \\end{algorithm}\n\n\n\n\nCode for Successive elimination\nfrom random import random, randrange\nfrom numpy import argmax, divide, errstate, inf, nan, log, sqrt\nimport numpy as np\n\nclass SuccessiveElimination:\n    def __init__(self, K, T, delta=1500):\n        self.num = log(2 * K * T / delta) / 2\n        assert self.num &gt; 0, \"delta too large\"\n        self.totals = [0] * K\n        self.counts = [0] * K\n        self.A = list(range(K))\n        self.idx = 0\n    \n    def __str__(self):\n        return \"Successive elimination\"\n\n    def _mu(self):\n        with errstate(divide='ignore', invalid='ignore'):\n            mu = divide(self.totals, self.counts)\n        mu[mu == inf] = 0\n        mu[mu == nan] = 0\n        return mu\n\n    def _beta(self):\n        with errstate(divide='ignore'):\n            beta = sqrt(divide(self.num, self.counts))\n        return beta\n\n    def play(self, t):\n        '''Choose an arm to play.'''\n        if self.idx == len(self.A):\n            # Update arm set A\n            u, b = self._mu(), self._beta()\n            lcb, ucb = u-b, u+b\n            self.A = [a for a in self.A if ucb[a] &gt;= np.max(lcb)]\n            self.idx = 0\n        # Play each arm in A\n        a = self.A[self.idx]\n        self.idx += 1\n        return a\n    \n    def feedback(self, t, a, r):\n        '''Receive a reward.'''\n        self.totals[a] += r\n        self.counts[a] += 1\n\n\n\n\nUCB\nJi (2022, Lecture 15)\n\n\n\\begin{algorithm} \\caption{UCB} \\begin{algorithmic} \\Require{$K$ and $T$ (both known), unknown reward distributions $\\mathcal{D}_a$.} \\For{$t = 1, 2, \\ldots$} \\State $a_t = \\arg\\max_{a \\in [K]} \\mathrm{UCB}_t (a)$ \\EndFor \\end{algorithmic} \\end{algorithm}\n\n\n\n\nCode for UCB\nfrom random import random, randrange\nfrom numpy import argmax, divide, errstate, inf, nan, log, sqrt\nimport numpy as np\n\nclass UCB:\n    def __init__(self, K, T, delta=1):\n        self.num = log(2 * K * T / delta) / 2\n        assert self.num &gt; 0, \"delta too large\"\n        self.totals = [0] * K\n        self.counts = [0] * K\n    \n    def __str__(self):\n        return \"UCB\"\n\n    def _mu(self):\n        with errstate(divide='ignore', invalid='ignore'):\n            mu = divide(self.totals, self.counts)\n        mu[mu == inf] = 0\n        mu[mu == nan] = 0\n        return mu\n\n    def _beta(self):\n        with errstate(divide='ignore'):\n            beta = sqrt(divide(self.num, self.counts))\n        return beta\n\n    def play(self, t):\n        '''Choose an arm to play.'''\n        ucb = self._mu() + self._beta()\n        return argmax(ucb)\n    \n    def feedback(self, t, a, r):\n        '''Receive a reward.'''\n        self.totals[a] += r\n        self.counts[a] += 1\n\n\n\n\nSimulation\n\nTechnical note\n\n\nSeed random number generators\nfrom random import seed as py_seed\nfrom numpy.random import seed as np_seed\npy_seed(5805)\nnp_seed(5805)\n\n\nWelford’s online algorithm\n\n\nSimulation code\nfrom random import random\nfrom numpy.random import normal\nfrom numpy import zeros, sqrt\n\n# Simulation parameters\nT = 1000    # Number of rounds\nF = 10      # Logging frequency\nN = 100     # Number of trials\n\n# Arms to explore\nmeans = [0.5, 0.6]\nbest = max(means)\narms = [random, lambda: normal(means[1], 0.2, 1).item()]\nK = len(arms)\n\n# Algorithms to use\ncs = [ExploreExploit, EpsilonGreedy, SuccessiveElimination, UCB]\nA = len(cs)\n\n# Evaluate algorithms\nx = zeros((T//F+1, A))\ns = zeros((T//F+1, A))\nfor n in range(1, N+1):\n    for i, c in enumerate(cs):\n        alg = c(K, T)\n        rgt = 0\n        for t in range(1, T+1):\n            a = alg.play(t)\n            r = arms[a]()\n            alg.feedback(t, a, r)\n            rgt += best - r\n            if t % F == 0:\n                # Welford's online algorithm\n                xn1 = x[t//F, i]\n                x[t//F, i] = ((n-1)*xn1 + rgt) / n\n                s[t//F, i] += (rgt - xn1) * (rgt - x[t//F, i])\ns = 0.2*sqrt(s / (N-1))\n\n\n\n\nCode for plotting regret\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nt = np.arange(1, T+2, F)\nplt.plot(t, x)\nfor i in range(A):\n    plt.fill_between(t, x[:,i]-s[:,i], x[:,i]+s[:,i], alpha=.15)\nplt.xlabel(\"Timestep\")\nplt.ylabel(\"Regret\")\nplt.legend([c(K, T) for c in cs]);\n\n\n\n\n\nFigure 1: Performance of MAB algorithms"
  },
  {
    "objectID": "2-clustering.html",
    "href": "2-clustering.html",
    "title": "Clustering",
    "section": "",
    "text": "Scatterplot matrix code by sklearn\n# Directly taken from:\n# https://scikit-learn.org/stable/auto_examples/cluster/plot_cluster_comparison.html\n\nimport time\nimport warnings\nfrom itertools import cycle, islice\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom sklearn import cluster, datasets, mixture\nfrom sklearn.neighbors import kneighbors_graph\nfrom sklearn.preprocessing import StandardScaler\n\nfrom ssc import linear, SparseSubspaceClustering\n\n# ============\n# Generate datasets. We choose the size big enough to see the scalability\n# of the algorithms, but not too big to avoid too long running times\n# ============\nn_samples = 200\nseed = 5805\nnoisy_circles = datasets.make_circles(\n    n_samples=n_samples, factor=0.5, noise=0.05, random_state=seed\n)\nnoisy_moons = datasets.make_moons(n_samples=n_samples, noise=0.05, random_state=seed)\nblobs = datasets.make_blobs(n_samples=n_samples, random_state=seed)\nrng = np.random.RandomState(seed)\nno_structure = rng.rand(n_samples, 2), None\n\n# Anisotropicly distributed data\nrandom_state = 5805\nX, y = datasets.make_blobs(n_samples=n_samples, random_state=random_state)\ntransformation = [[0.6, -0.6], [-0.4, 0.8]]\nX_aniso = np.dot(X, transformation)\naniso = (X_aniso, y)\n\n# blobs with varied variances\nvaried = datasets.make_blobs(\n    n_samples=n_samples, cluster_std=[1.0, 2.5, 0.5], random_state=random_state\n)\n\n# ============\n# Set up cluster parameters\n# ============\nplt.figure(figsize=(10.5, 6.5))\nplt.subplots_adjust(\n    left=0.02, right=0.98, bottom=0.001, top=0.95, wspace=0.01, hspace=0.01\n)\n\nplot_num = 1\n\ndefault_base = {\n    \"quantile\": 0.3,\n    \"eps\": 0.3,\n    \"damping\": 0.9,\n    \"preference\": -200,\n    \"n_neighbors\": 3,\n    \"n_clusters\": 3,\n    \"min_samples\": 7,\n    \"xi\": 0.05,\n    \"min_cluster_size\": 0.1,\n    \"allow_single_cluster\": True,\n    \"hdbscan_min_cluster_size\": 15,\n    \"hdbscan_min_samples\": 3,\n    \"random_state\": 42,\n}\n\ndatasets = [\n    (\n        noisy_circles,\n        {\n            \"damping\": 0.77,\n            \"preference\": -240,\n            \"quantile\": 0.2,\n            \"n_clusters\": 2,\n            \"min_samples\": 7,\n            \"xi\": 0.08,\n        },\n    ),\n    (\n        noisy_moons,\n        {\n            \"damping\": 0.75,\n            \"preference\": -220,\n            \"n_clusters\": 2,\n            \"min_samples\": 7,\n            \"xi\": 0.1,\n        },\n    ),\n    (\n        varied,\n        {\n            \"eps\": 0.18,\n            \"n_neighbors\": 2,\n            \"min_samples\": 7,\n            \"xi\": 0.01,\n            \"min_cluster_size\": 0.2,\n        },\n    ),\n    (\n        aniso,\n        {\n            \"eps\": 0.15,\n            \"n_neighbors\": 2,\n            \"min_samples\": 7,\n            \"xi\": 0.1,\n            \"min_cluster_size\": 0.2,\n        },\n    ),\n    (blobs, {\"min_samples\": 7, \"xi\": 0.1, \"min_cluster_size\": 0.2}),\n    (linear, {}),\n    (no_structure, {}),\n]\n\nfor i_dataset, (dataset, algo_params) in enumerate(datasets):\n    # update parameters with dataset-specific values\n    params = default_base.copy()\n    params.update(algo_params)\n\n    X, y = dataset\n\n    # normalize dataset for easier parameter selection\n    X = StandardScaler().fit_transform(X)\n\n    # estimate bandwidth for mean shift\n    bandwidth = cluster.estimate_bandwidth(X, quantile=params[\"quantile\"])\n\n    # connectivity matrix for structured Ward\n    connectivity = kneighbors_graph(\n        X, n_neighbors=params[\"n_neighbors\"], include_self=False\n    )\n    # make connectivity symmetric\n    connectivity = 0.5 * (connectivity + connectivity.T)\n\n    # ============\n    # Create cluster objects\n    # ============\n    ms = cluster.MeanShift(bandwidth=bandwidth, bin_seeding=True)\n    two_means = cluster.MiniBatchKMeans(\n        n_clusters=params[\"n_clusters\"],\n        n_init=\"auto\",\n        random_state=params[\"random_state\"],\n    )\n    ward = cluster.AgglomerativeClustering(\n        n_clusters=params[\"n_clusters\"], linkage=\"ward\", connectivity=connectivity\n    )\n    spectral = cluster.SpectralClustering(\n        n_clusters=params[\"n_clusters\"],\n        eigen_solver=\"arpack\",\n        affinity=\"nearest_neighbors\",\n        random_state=params[\"random_state\"],\n    )\n    dbscan = cluster.DBSCAN(eps=params[\"eps\"])\n    hdbscan = cluster.HDBSCAN(\n        min_samples=params[\"hdbscan_min_samples\"],\n        min_cluster_size=params[\"hdbscan_min_cluster_size\"],\n        allow_single_cluster=params[\"allow_single_cluster\"],\n    )\n    optics = cluster.OPTICS(\n        min_samples=params[\"min_samples\"],\n        xi=params[\"xi\"],\n        min_cluster_size=params[\"min_cluster_size\"],\n    )\n    affinity_propagation = cluster.AffinityPropagation(\n        damping=params[\"damping\"],\n        preference=params[\"preference\"],\n        random_state=params[\"random_state\"],\n    )\n    average_linkage = cluster.AgglomerativeClustering(\n        linkage=\"average\",\n        metric=\"cityblock\",\n        n_clusters=params[\"n_clusters\"],\n        connectivity=connectivity,\n    )\n    birch = cluster.Birch(n_clusters=params[\"n_clusters\"])\n    gmm = mixture.GaussianMixture(\n        n_components=params[\"n_clusters\"],\n        covariance_type=\"full\",\n        random_state=params[\"random_state\"],\n    )\n    ssc = SparseSubspaceClustering(\n        n_clusters=params[\"n_clusters\"],\n    )\n\n    clustering_algorithms = (\n        (\"MiniBatch\\nKMeans\", two_means),\n        (\"Affinity\\nPropagation\", affinity_propagation),\n        (\"MeanShift\", ms),\n        (\"Spectral\\nClustering\", spectral),\n        (\"Ward\", ward),\n        (\"Agglomerative\\nClustering\", average_linkage),\n        (\"DBSCAN\", dbscan),\n        (\"HDBSCAN\", hdbscan),\n        (\"OPTICS\", optics),\n        (\"BIRCH\", birch),\n        (\"Gaussian\\nMixture\", gmm),\n        (\"Sparse\\nSubspace\\nClustering\", ssc),\n    )\n\n    for name, algorithm in clustering_algorithms:\n        t0 = time.time()\n\n        # catch warnings related to kneighbors_graph, subspace clustering\n        with warnings.catch_warnings():\n            warnings.filterwarnings(\n                \"ignore\",\n                message=\"the number of connected components of the \"\n                + \"connectivity matrix is [0-9]{1,2}\"\n                + \" &gt; 1. Completing it to avoid stopping the tree early.\",\n                category=UserWarning,\n            )\n            warnings.filterwarnings(\n                \"ignore\",\n                message=\"Graph is not fully connected, spectral embedding\"\n                + \" may not work as expected.\",\n                category=UserWarning,\n            )\n            warnings.filterwarnings(\n                \"ignore\",\n                message=\"Solution may be inaccurate. Try another solver,\"\n                + \" adjusting the solver settings, or solve with\"\n                + \" verbose=True for more information.\",\n                category=UserWarning,\n            )\n            algorithm.fit(X)\n\n        t1 = time.time()\n        if hasattr(algorithm, \"labels_\"):\n            y_pred = algorithm.labels_.astype(int)\n        else:\n            y_pred = algorithm.predict(X)\n\n        plt.subplot(len(datasets), len(clustering_algorithms), plot_num)\n        if i_dataset == 0:\n            plt.title(name, size=9)\n\n        colors = np.array(\n            list(\n                islice(\n                    cycle(\n                        [\n                            \"#377eb8\",\n                            \"#ff7f00\",\n                            \"#4daf4a\",\n                            \"#f781bf\",\n                            \"#a65628\",\n                            \"#984ea3\",\n                            \"#999999\",\n                            \"#e41a1c\",\n                            \"#dede00\",\n                        ]\n                    ),\n                    int(max(y_pred) + 1),\n                )\n            )\n        )\n        # add black color for outliers (if any)\n        colors = np.append(colors, [\"#000000\"])\n        plt.scatter(X[:, 0], X[:, 1], s=5, color=colors[y_pred])\n\n        plt.xlim(-2.5, 2.5)\n        plt.ylim(-2.5, 2.5)\n        plt.xticks(())\n        plt.yticks(())\n        plt.text(\n            0.99,\n            0.01,\n            (\"%.2fs\" % (t1 - t0)).lstrip(\"0\"),\n            transform=plt.gca().transAxes,\n            size=7.5,\n            horizontalalignment=\"right\",\n        )\n        plot_num += 1\n\nplt.show()\n\n\n\n\n\nA comparison of various clustering methods.\n\n\n\n\n# The 'X'-looking dataset\n\nlinear = np.concatenate((\n        rng.rand(n_samples//2, 2),                              # □ Square\n        rng.rand(n_samples//4, 2) * 0.05\n            + np.repeat(rng.rand(n_samples//4, 1), 2, axis=1),  # / Diagonal\n        rng.rand(n_samples//4, 2) * 0.05\n            + np.repeat(rng.rand(n_samples//4, 1), 2, axis=1)   # \\ Diagonal\n            * [1, -1] + [0, 1]\n    ), axis=0) - [0.5, 0.5], None\ndef fit(self, Y):\n    Y = Y.T\n    d, n = Y.shape\n    assert d &lt; n\n\n    ## 1. Solve sparse optimization problem\n\n    # Starting form, equation (5)\n    C = Variable((n, n))\n    objective = norm(C,1)\n    constraint = Y @ C\n\n    # Account for outliers\n    if self.use_E:\n        mu_e = np.partition(np.sum(np.abs(Y), axis=0), -2)[-2]\n        l_e = 20 / mu_e\n        E = Variable((d, n))\n        objective += l_e * norm(E,1)\n        constraint += E\n\n    # Account for noise\n    if self.use_Z:\n        G = np.abs(Y.T @ Y)\n        mu_z = np.min(np.max(G - np.diag(np.diag(G)), axis=1))\n        l_z = 800 / mu_z\n        Z = Variable((d, n))\n        objective += l_z/2 * norm(Z,\"fro\")**2\n        constraint += Z\n\n    constraints = [Y == constraint, diag(C) == 0]\n    prob = Problem(Minimize(objective), constraints)\n    try:\n        prob.solve(solver=ECOS)\n\n        ## 2. Normalize the columns of C\n        C = C.value / np.max(np.abs(C.value), axis=0)\n\n        ## 3. Form the weights of a similarity graph\n        W = np.abs(C)\n        W = W + W.T\n\n        ## 4. Apply spectral clustering on the graph\n        self.labels_ = SpectralClustering(\n                n_clusters=self.n_clusters,\n                affinity='precomputed'\n            ).fit_predict(W)\n    except SolverError:\n        self.labels_ = np.zeros(n)"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  }
]